<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secure Automation Dashboard</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">

  <link rel="stylesheet" href="https://cdn.datatables.net/1.10.23/css/jquery.dataTables.min.css">
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
  <script src="https://cdn.datatables.net/1.10.23/js/jquery.dataTables.min.js"></script>
  <script src="speedometer.js"></script>


  <style>
    .tabs{
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    .tab{
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    .tab:hover{
      background-color: rgba(255, 255, 255, 0.2);
    }
  body {
    margin: 0;
    padding: 0;
    background-color: #1d2634;
    color: #9e9ea4;
    font-family: 'Montserrat', 'sans-serif';
  }

  .grid-container {
    display: grid;
    grid-template-columns: 260px 1fr 1fr 1fr;
    grid-template-rows: 60px 1fr;
    grid-template-areas: 'sidebar header header header' 'sidebar main main main';
    height: 100vh;
  }

  .icon {
    vertical-align: middle;
    line-height: 1px;
    font-size: 20px;
  }

  .icon_header {
    vertical-align: middle;
    line-height: 1px;
    font-size: 26px;
  }

  .icon,
  .icon_header {
    margin-right: 5px;
  }

  /* Header */

  .header {
    grid-area: header;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 30px;
    box-shadow: 0 6px 7px -3px rgba(0, 0, 0, 0.35);
    background-color: #263043;
    z-index: 2;
  }

  .menu-icon {
    display: none;
  }

  /* End Header */

  /* Sidebar */

  #sidebar {
    grid-area: sidebar;
    background-color: #263043;
    overflow: hidden;
    transition: all 0.5s;
    -webkit-transition: all 0.5s;
    position: fixed;
    /* left: 0; */
    top: 0;
    bottom: 0;
    /* z-index: 1; */
  }

  .sidebar-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 30px 0px 30px;
    margin-bottom: 30px;
  }

  .sidebar-title>span {
    display: none;
  }

  .sidebar-brand {
    margin-top: 15px;
    font-size: 20px;
    font-weight: 700;
    color: #fff; /* Adjust the color as needed */
  }

  .sidebar-list {
    padding: 0;
    list-style-type: none;
  }

  .sidebar-list-item {
    padding: 20px 20px 20px 20px;
    font-size: 18px;
  }

  .sidebar-list-item:hover {
    background-color: rgba(255, 255, 255, 0.2);
    cursor: pointer;
  }

  .sidebar-list-item>a {
    text-decoration: none;
    color: #9e9ea4;
  }

  .sidebar-responsive {
    display: inline !important;
    position: absolute;
    z-index: 12 !important;
  }

  /* End Sidebar  */

  h1 {
    color: #61dafb;
  }

  .form-group {
    margin-bottom: 20px;
    display: inline !important;
    flex-wrap: wrap;

  }

  input[type="date"] {
    width: calc(10% - 10px);
    display:inline-block;
    margin-right: 10px;
    padding: 10px;
    margin-top: 5px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background-color: #fff;
    color: #333;
  }


  button {
    background-color: transparent;
    color: #000;
    
    padding: 8px 15px;
    
    border: none;
    border-radius: 5px;
    cursor: pointer;
    width: 100%;

  }

  .mt-4 {
    margin-top: 20px;
  }

  .list-group-item {
    background-color: transparent !important;
    /* border: 1px solid #333; */
    
    margin-bottom: 5px;
    color: #000;
  }

  #barChart,
  #pieChart,
  #lineChart,
  #dataTableContainer {
    border: 1px solid #333;
    background-color: #fff;
    margin-top: 10px;
    padding: 20px;
    border-radius: 10px;
    max-height: 400px;
    overflow-y: auto;
  }

  #dataList2Table {
    width: 100%;
    border-collapse: collapse;
    background-color: #39424e;
    color: #fff;
  }

  #dataList2Table.dataTable tbody {
    background-color: #39424e !important;
    color: #000 !important;
  }

  #dataList2Table.dataTable th,
  #dataList2Table.dataTable td {
    border: 1px solid #333 !important;
    padding: 8px !important;
    text-align: left;
  }

  #dataList2Table.dataTable th {
    background-color: #333 !important;
    /* color: #000 !important; */
  }

  #dataList2Table.dataTable_paginate {
    color: #000 !important;
  }

  .main-container {
    grid-area: main;
    overflow: hidden;
    padding: 20px;
    color: rgba(255, 255, 255, 0.95);
    padding-left: 300px;
    /* margin-top: 60px;
    margin-left: 260px; */
    /* position: relative;
    z-index: 0; */
  }

  .main-title {
    display: flex;
    justify-content: space-between;
  }

  .main-cards {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr 1fr;
    gap: 20px;
    margin: 15px 0;
  }

  .card {
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    padding: 8px 15px;
    border-radius: 5px;
  }

  .card:first-child {
    background-color: #2962ff;
  }

  .card:nth-child(2) {
    background-color: #ff6d00;
  }

  .card:nth-child(3) {
    background-color: #2e7d32;
  }

  .card:nth-child(4) {
    background-color: #d50000;
  }

  .card-inner {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .card-inner>.card_icon {
    font-size: 25px;
  }

  .charts {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 60px;
    height: 200px;
    width: (100% - 500px);
  }
  .custom-submit-btn{
    width: 100px;
  }

 
  .bar-chart-container,
  .line-chart-container,
  .pie-chart-container{
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 20px;
  }

  #dataList1 {
    list-style: none;
    background-color: transparent !important;
    padding: 0;
  }

  #dataList1 li {
    margin-bottom: 5px;
    background-color: #39424e;
    border: 1px solid #333;
    color: #000;
    padding: 8px;
  }

  .meter{
    position: relative;
    width: 200px;
    height: 200px;
    background-color: #f0f0f0;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    box-shadow: 0px 0px 10px rgba(0,0,0,0.2);
  }

  .needle{
    position: absolute;
    width: 4px;
    height: 50%;
    background-color: #4CAF50;
    transform-origin:50% 100% ;
    transition:transform 0.5s ease-in-out;
  }

  .needle::after{
    content:"";
    position: absolute;
    width: 3px;
    height: 60px;
    background-color: black;
    top: -30px;
    left: 50%;
    transform:
    translateX(-50%);
    border-radius: 2px;
  }

  .reading {
    position: absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    font-size: 36px;
    font-weight: bold;
    color: #333;
    margin-bottom: 10px;
  }
</style>

</head>

<body>
  <div id="root">
    <header class='header'>
      <div class='menu-icon'>
        <!-- Replace with your icon component -->
      </div>

      <div class='header-left'>
        <!-- Replace with your icon component -->
      </div>

      <div class='header-right'>
        <!-- Replace with your icon components -->
      </div>
    </header>

    <aside id="sidebar">
      <div class='sidebar-title'>
        <div class='sidebar-brand'>
          <!-- Replace with your icon component -->
          SECURE AUTOMATION
        </div>

        <span class='icon close_icon'>X</span>
      </div>

      <ul class='sidebar-list'>
        <li class='sidebar-list-item'>
          <a href="">
            <!-- Replace with your icon component -->
            DASHBOARD
          </a>
        </li>
        <li class='sidebar-list-item'>
          <a href="https://secure.uhc.com/">
            <!-- Replace with your icon component -->
            SECURE
          </a>
        </li>
        <li class='sidebar-list-item'>
          <a href="https://glxyutil.uhc.com/security/Sync_Exceptions_Applicationwise_Count.htm">
            <!-- Replace with your icon component -->
            EXCEPTIONS
          </a>
        </li>
        <li class='sidebar-list-item'>
          <a href="https://datasecurity.uhc.com/cgi-bin/home.cgi?src=FAQ_security.htm#list_secure_apps">
            <!-- Replace with your icon component -->
            KA PAGE
          </a>
        </li>
        <li class='sidebar-list-item'>
          <a href="https://uhgazure.sharepoint.com/sites/B1/600/601/inttm/601.2/I001/Forms/PubDocs.aspx?InitialTabId=Ribbon%2ERead&VisibilityContext=WSSTabPersistence&OR=Teams%2DHL&CT=1635319446676">
            <!-- Replace with your icon component -->
            Sharepoint
          </a>
        </li>
        <li class='sidebar-list-item'>
          <a href="">
            <!-- Replace with your icon component -->
            Settings
          </a>
        </li>
      </ul>
    </aside>

    <main class='main-container'>
      <!-- <div class='main-title'>
        <h3>DASHBOARD</h3>
      </div> -->


      <div id="meter"  style="display: none;">
        <canvas id="speedometer" width="440" height="220">Canvas not available.</canvas>
        <div>
        <form id="drawTemp">
            <input type="text" id="txtSpeed" name="txtSpeed" value="20" maxlength="2"/>
            <input type="button" value="Draw" onclick="drawWithInputValue();">
        </form>
        </div>  

      </div>





      <div id="dateContainer" style="display: none;">
      <div class="form-group">
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate" class="form-control">
      </div>

      <div class="form-group">
        <label for="endDate">End Date:</label>
        <input type="date" id="endDate" class="form-control">
      </div>

      <button class="btn btn-primary custom-submit-btn" onclick="updateCharts()">Submit</button>
    </div>

    
      <div class='main-cards'>
        <div class='card'>
          <div class="tabs">
          <div class='card-inner'>
            <button class="tab" onclick="showApplications()">APPLICATIONS</button>
            <i class='card_icon bi bi-grid-3x3-gap-fill'></i>
          </div>
          <h1></h1>
        </div></div>

        <div class='card'>
          <div class="tabs">
          <div class='card-inner'>
            <button class="tab" onclick="showRequests()">REQUESTS</button>
            <h1 id="dataList1" class="list-group" ></h1>
            <i class='card_icon bi bi-archive-fill'></i>
          </div>
        </div>
        
        </div>
        

        

        <div class='card'>
          <div class="tabs">
          <div class='card-inner'>
            <button class="tab" onclick="showBenefit()">BENEFIT</button>
            <i class='card_icon bi bi-people-fill'></i>
          </div>
          <!-- <h1>33</h1> -->
        </div>

        </div>
      </div>

      <!-- <div class="form-group">
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate" class="form-control">
      </div>

      <div class="form-group">
        <label for="endDate">End Date:</label>
        <input type="date" id="endDate" class="form-control">
      </div>

      <button class="btn btn-primary custom-submit-btn" onclick="updateCharts()">Submit</button> -->

      

      <!-- <div class="charts-container"> -->
        <div id="dataContainer2" class="mt-4" style="display: none;">
          <h3>Information of Requests handled by Secure Automation</h3>
          <div id="dataTableContainer">
            <table id="dataList2Table" class="display">
              <!-- Data will be dynamically added here -->
            </table>
            <button id="downloadCSVBtn" class="btn btn-primary mt-2">Download CSV</button>
          </div>
        </div>


        <!-- <div class="meter" id="meter" style="display: none;">
          <div class="needle" id="needle"></div>
          <div class="reading">0</div>
        </div> -->
        

        
        <div className='charts'>
          <!-- <div id="chartsContainer1" class="mt-4" style="display: none;">
            <div class="line-chart-container">
              <canvas id="lineChart" width="800" height="400"></canvas>
            </div>

          
          </div> -->

          <div id="chartsContainer" class="mt-4">
          <div id="barchartsContainer" class='bar-chart-container' style="display: none;">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart width={500} height={300} data={data} margin="{{ top:20 , right:30,left:20,bottom:5}}">
                <canvas id="barChart" width="500" height="300">
                  <CartesianGrid>
                    <XAxis dataKey="name" />
                    <YAxis />
                    <Tooltip />
                    <Bar dataKey="value" fill="#61dafb" />
    
                  </CartesianGrid>
                </canvas>
    
              </BarChart>
            </ResponsiveContainer>
          </div>
      
          <div id="piechartsContainer" class='pie-chart-container' style="display: none;">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart width={500} height={300}>
                <canvas id="pieChart" width="500" height="300">
                  <Pie
                    dataKey="value"
                    isAnimationActive={false}
                    data={data}
                    cx="50%"
                    cy="50%"
                    outerRadius={80}
                    fill="#61dafb"
                    label>
                  </Pie>
                </canvas>
              </PieChart>
            </ResponsiveContainer>
          </div>


          <div id="linechartsContainer" class='line-chart-container' style="display: none;">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart width={500} height={300} data={data} margin="{{ top:20 , right:30,left:20,bottom:5}}">
                <canvas id="lineChartCanvas" width="400" height="400">
                  <CartesianGrid>
                    <XAxis dataKey="name" />
                    <YAxis />
                    <Tooltip />
                    <Bar dataKey="value" fill="#61dafb" />
    
                  </CartesianGrid>
                </canvas>
              </LineChart>
            </ResponsiveContainer>
          </div>
        </div>
      </div>
        

      <!-- <div className='charts'>
        <div id="chartsContainer1" class="mt-4" style="display: none;">
          <div class="line-chart-container">
            <canvas id="lineChart" width="800" height="400"></canvas>
          </div>

        
        </div>
      </div> -->




    <!-- </div> -->


    
    <!-- </div> -->

      
    </main>
  </div>


  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.2.0/d3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.2.2/echarts.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.2.2/extension/dataTool.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.2.2/extension/bmap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.2.2/extension/wordcloud.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.2.2/extension/graphic.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.2.2/extension/bmap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.2.2/extension/dataZoom.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.2.2/extension/calendar.min.js"></script> -->


  <!-- https://secure.uhc.com/User/ViewRequestDetail?requestId=404363321 -->

  <script>
// *********************************************************************************************************
    
        /*jslint plusplus: true, sloppy: true, indent: 4 */
        (function () {
            "use strict";
            // this function is strict...
        }());

        var iCurrentSpeed = 20,
            iTargetSpeed = 20,
            bDecrement = null,
            job = null;

        function degToRad(angle) {
            // Degrees to radians
            return ((angle * Math.PI) / 180);
        }

        function radToDeg(angle) {
            // Radians to degree
            return ((angle * 180) / Math.PI);
        }

        function drawLine(options, line) {
            // Draw a line using the line object passed in
            options.ctx.beginPath();

            // Set attributes of open
            options.ctx.globalAlpha = line.alpha;
            options.ctx.lineWidth = line.lineWidth;
            options.ctx.fillStyle = line.fillStyle;
            options.ctx.strokeStyle = line.fillStyle;
            options.ctx.moveTo(line.from.X,
                line.from.Y);

            // Plot the line
            options.ctx.lineTo(
                line.to.X,
                line.to.Y
            );

            options.ctx.stroke();
        }

        function createLine(fromX, fromY, toX, toY, fillStyle, lineWidth, alpha) {
            // Create a line object using Javascript object notation
            return {
                from: {
                    X: fromX,
                    Y: fromY
                },
                to:    {
                    X: toX,
                    Y: toY
                },
                fillStyle: fillStyle,
                lineWidth: lineWidth,
                alpha: alpha
            };
        }

        function drawOuterMetallicArc(options) {
            /* Draw the metallic border of the speedometer
            * Outer grey area
            */
        /*    options.ctx.beginPath();

            // Nice shade of grey
            options.ctx.fillStyle = "rgb(127,127,127)";

            // Draw the outer circle
            options.ctx.arc(options.center.X,
                options.center.Y,
                options.radius,
                0,
                Math.PI,
                true);

            // Fill the last object
            options.ctx.fill();
        */
        }

        function drawInnerMetallicArc(options) {
            /* Draw the metallic border of the speedometer
            * Inner white area
            */

            /*options.ctx.beginPath();

            // White
            options.ctx.fillStyle = "rgb(255,255,255)";

            // Outer circle (subtle edge in the grey)
            options.ctx.arc(options.center.X,
                            options.center.Y,
                            (options.radius / 100) * 90,
                            0,
                            Math.PI,
                            true);

            options.ctx.fill();
            
            */
        }

        function drawMetallicArc(options) {
            /* Draw the metallic border of the speedometer
            * by drawing two semi-circles, one over lapping
            * the other with a bot of alpha transparency
            */

            drawOuterMetallicArc(options);
            drawInnerMetallicArc(options);
        }

        function drawBackground(options) {
            /* Black background with alphs transparency to
            * blend the edges of the metallic edge and
            * black background
            */
          var i = 0;

            options.ctx.globalAlpha = 0.2;
            options.ctx.fillStyle = "rgb(0,0,0)";

            // Draw semi-transparent circles
            for (i = 170; i < 180; i++) {
                options.ctx.beginPath();

                options.ctx.arc(options.center.X,
                    options.center.Y,
                    i,
                    0,
                    Math.PI,
                    true);

                options.ctx.fill();
            }
            
        }

        function applyDefaultContextSettings(options) {
            /* Helper function to revert to gauges
            * default settings
            */

            options.ctx.lineWidth = 2;
            options.ctx.globalAlpha = 0.5;
            options.ctx.strokeStyle = "rgb(255, 255, 255)";
            options.ctx.fillStyle = 'rgb(255,255,255)';
        }

        function drawSmallTickMarks(options) {
            /* The small tick marks against the coloured
            * arc drawn every 5 mph from 10 degrees to
            * 170 degrees.
            */

            var tickvalue = options.levelRadius - 8,
                iTick = 0,
                gaugeOptions = options.gaugeOptions,
                iTickRad = 0,
                onArchX,
                onArchY,
                innerTickX,
                innerTickY,
                fromX,
                fromY,
                line,
                toX,
                toY;

            applyDefaultContextSettings(options);

            // Tick every 20 degrees (small ticks)
            for (iTick = 10; iTick < 180; iTick += 20) {

                iTickRad = degToRad(iTick);

                /* Calculate the X and Y of both ends of the
                * line I need to draw at angle represented at Tick.
                * The aim is to draw the a line starting on the
                * coloured arc and continueing towards the outer edge
                * in the direction from the center of the gauge.
                */

                onArchX = gaugeOptions.radius - (Math.cos(iTickRad) * tickvalue);
                onArchY = gaugeOptions.radius - (Math.sin(iTickRad) * tickvalue);
                innerTickX = gaugeOptions.radius - (Math.cos(iTickRad) * gaugeOptions.radius);
                innerTickY = gaugeOptions.radius - (Math.sin(iTickRad) * gaugeOptions.radius);

                fromX = (options.center.X - gaugeOptions.radius) + onArchX;
                fromY = (gaugeOptions.center.Y - gaugeOptions.radius) + onArchY;
                toX = (options.center.X - gaugeOptions.radius) + innerTickX;
                toY = (gaugeOptions.center.Y - gaugeOptions.radius) + innerTickY;

                // Create a line expressed in JSON
                line = createLine(fromX, fromY, toX, toY, "rgb(127,127,127)", 3, 0.6);

                // Draw the line
                drawLine(options, line);

            }
        }

        function drawLargeTickMarks(options) {
            /* The large tick marks against the coloured
            * arc drawn every 10 mph from 10 degrees to
            * 170 degrees.
            */

            var tickvalue = options.levelRadius - 8,
                iTick = 0,
                gaugeOptions = options.gaugeOptions,
                iTickRad = 0,
                innerTickY,
                innerTickX,
                onArchX,
                onArchY,
                fromX,
                fromY,
                toX,
                toY,
                line;

            applyDefaultContextSettings(options);

            tickvalue = options.levelRadius - 2;

            // 10 units (major ticks)
            for (iTick = 20; iTick < 180; iTick += 20) {

                iTickRad = degToRad(iTick);

                /* Calculate the X and Y of both ends of the
                * line I need to draw at angle represented at Tick.
                * The aim is to draw the a line starting on the
                * coloured arc and continueing towards the outer edge
                * in the direction from the center of the gauge.
                */

                onArchX = gaugeOptions.radius - (Math.cos(iTickRad) * tickvalue);
                onArchY = gaugeOptions.radius - (Math.sin(iTickRad) * tickvalue);
                innerTickX = gaugeOptions.radius - (Math.cos(iTickRad) * gaugeOptions.radius);
                innerTickY = gaugeOptions.radius - (Math.sin(iTickRad) * gaugeOptions.radius);

                fromX = (options.center.X - gaugeOptions.radius) + onArchX;
                fromY = (gaugeOptions.center.Y - gaugeOptions.radius) + onArchY;
                toX = (options.center.X - gaugeOptions.radius) + innerTickX;
                toY = (gaugeOptions.center.Y - gaugeOptions.radius) + innerTickY;

                // Create a line expressed in JSON
                line = createLine(fromX, fromY, toX, toY, "rgb(127,127,127)", 3, 0.6);

                // Draw the line
                drawLine(options, line);
            }
        }

        function drawTicks(options) {
            /* Two tick in the coloured arc!
            * Small ticks every 5
            * Large ticks every 10
            */
            drawSmallTickMarks(options);
            drawLargeTickMarks(options);
        }

        function drawTextMarkers(options) {
            /* The text labels marks above the coloured
            * arc drawn every 10 mph from 10 degrees to
            * 170 degrees.
            */
            var innerTickX = 0,
                innerTickY = 0,
                iTick = 0,
                gaugeOptions = options.gaugeOptions,
                iTickToPrint = 00;

            applyDefaultContextSettings(options);

            // Font styling
            options.ctx.font = 'italic 10px sans-serif';
            options.ctx.textBaseline = 'top';

            options.ctx.beginPath();

            // Tick every 20 (small ticks)
            for (iTick = 10; iTick < 180; iTick += 20) {

                innerTickX = gaugeOptions.radius - (Math.cos(degToRad(iTick)) * gaugeOptions.radius);
                innerTickY = gaugeOptions.radius - (Math.sin(degToRad(iTick)) * gaugeOptions.radius);

                // Some cludging to center the values (TODO: Improve)
                if (iTick <= 10) {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX,
                            (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY + 5);
                } else if (iTick < 50) {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX - 5,
                            (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY + 5);
                } else if (iTick < 90) {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX,
                            (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY);
                } else if (iTick === 90) {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX + 4,
                            (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY);
                } else if (iTick < 145) {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX + 10,
                            (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY);
                } else {
                    options.ctx.fillText(iTickToPrint, (options.center.X - gaugeOptions.radius - 12) + innerTickX + 15,
                            (gaugeOptions.center.Y - gaugeOptions.radius - 12) + innerTickY + 5);
                }

                // MPH increase by 10 every 20 degrees
                //iTickToPrint += Math.round(2160 / 9);
                iTickToPrint += 10;
            }

            options.ctx.stroke();
        }

        function drawSpeedometerPart(options, alphaValue, strokeStyle, startPos) {
            /* Draw part of the arc that represents
            * the colour speedometer arc
            */

            options.ctx.beginPath();

            options.ctx.globalAlpha = alphaValue;
            options.ctx.lineWidth = 5;
            options.ctx.strokeStyle = strokeStyle;

            options.ctx.arc(options.center.X,
                options.center.Y,
                options.levelRadius,
                Math.PI + (Math.PI / 360 * startPos),
                0 - (Math.PI / 360 * 10),
                false);

            options.ctx.stroke();
        }

        function drawSpeedometerColourArc(options) {
            /* Draws the colour arc.  Three different colours
            * used here; thus, same arc drawn 3 times with
            * different colours.
            * TODO: Gradient possible?
            */

            var startOfGreen = 10,
                endOfGreen = 200,
                endOfOrange = 280;

            drawSpeedometerPart(options, 1.0, "rgb(204,254,255)", startOfGreen);
            drawSpeedometerPart(options, 0.9, "rgb(2,254,255)", endOfGreen);
            drawSpeedometerPart(options, 0.9, "rgb(1,127,127) ", endOfOrange);

        }

        function drawNeedleDial(options, alphaValue, strokeStyle, fillStyle) {
            /* Draws the metallic dial that covers the base of the
            * needle.
            */
            var i = 0;

            options.ctx.globalAlpha = alphaValue;
            options.ctx.lineWidth = 3;
            options.ctx.strokeStyle = strokeStyle;
            options.ctx.fillStyle = fillStyle;

            // Draw several transparent circles with alpha
            for (i = 0; i < 30; i++) {

                options.ctx.beginPath();
                options.ctx.arc(options.center.X,
                    options.center.Y,
                    i,
                    0,
                    Math.PI,
                    true);

                options.ctx.fill();
                options.ctx.stroke();
            }
        }

        function convertSpeedToAngle(options) {
            /* Helper function to convert a speed to the
            * equivelant angle.
            */
            var iSpeed = (options.speed / 10),
                iSpeedAsAngle = ((iSpeed * 20) + 10) % 180;

            // Ensure the angle is within range
            if (iSpeedAsAngle > 180) {
                iSpeedAsAngle = iSpeedAsAngle - 180;
            } else if (iSpeedAsAngle < 0) {
                iSpeedAsAngle = iSpeedAsAngle + 180;
            }

            return iSpeedAsAngle;
        }

        function drawNeedle(options) {
            /* Draw the needle in a nice read colour at the
            * angle that represents the options.speed value.
            */

            var iSpeedAsAngle = convertSpeedToAngle(options),
                iSpeedAsAngleRad = degToRad(iSpeedAsAngle),
                gaugeOptions = options.gaugeOptions,
                innerTickX = gaugeOptions.radius - (Math.cos(iSpeedAsAngleRad) * 20),
                innerTickY = gaugeOptions.radius - (Math.sin(iSpeedAsAngleRad) * 20),
                fromX = (options.center.X - gaugeOptions.radius) + innerTickX,
                fromY = (gaugeOptions.center.Y - gaugeOptions.radius) + innerTickY,
                endNeedleX = gaugeOptions.radius - (Math.cos(iSpeedAsAngleRad) * gaugeOptions.radius),
                endNeedleY = gaugeOptions.radius - (Math.sin(iSpeedAsAngleRad) * gaugeOptions.radius),
                toX = (options.center.X - gaugeOptions.radius) + endNeedleX,
                toY = (gaugeOptions.center.Y - gaugeOptions.radius) + endNeedleY,
                line = createLine(fromX, fromY, toX, toY, "rgb(127, 127, 127)", 5, 0.6);

            drawLine(options, line);

            // Two circle to draw the dial at the base (give its a nice effect?)
            drawNeedleDial(options, 0.6, "rgb(127, 127, 127)", "rgb(255,255,255)");
            drawNeedleDial(options, 0.2, "rgb(127, 127, 127)", "rgb(127,127,127)");

        }

        function buildOptionsAsJSON(canvas, iSpeed) {
            /* Setting for the speedometer
            * Alter these to modify its look and feel
            */

            var centerX = 210,
                centerY = 210,
                radius = 150,
                outerRadius = 200;

            // Create a speedometer object using Javascript object notation
            return {
                ctx: canvas.getContext('2d'),
                speed: iSpeed,
                center:    {
                    X: centerX,
                    Y: centerY
                },
                levelRadius: radius - 10,
                gaugeOptions: {
                    center:    {
                        X: centerX,
                        Y: centerY
                    },
                    radius: radius
                },
                radius: outerRadius
            };
        }

        function clearCanvas(options) {
            options.ctx.clearRect(0, 0, 800, 600);
            applyDefaultContextSettings(options);
        }

        function draw() {
            /* Main entry point for drawing the speedometer
            * If canvas is not support alert the user.
            */
                
            console.log('Target: ' + iTargetSpeed);
            console.log('Current: ' + iCurrentSpeed);
            
            var canvas = document.getElementById('speedometer'),
                options = null;

            // Canvas good?
            if (canvas !== null && canvas.getContext) {
                options = buildOptionsAsJSON(canvas, iCurrentSpeed);

                // Clear canvas
                clearCanvas(options);

                // Draw the metallic styled edge
                drawMetallicArc(options);

                // Draw thw background
                drawBackground(options);

                // Draw tick marks
                drawTicks(options);

                // Draw labels on markers
                drawTextMarkers(options);

                // Draw speeometer colour arc
                drawSpeedometerColourArc(options);

                // Draw the needle and base
                drawNeedle(options);
                
            } else {
                alert("Canvas not supported by your browser!");
            }
            
            if(iTargetSpeed == iCurrentSpeed) {
                clearTimeout(job);
                return;
            } else if(iTargetSpeed < iCurrentSpeed) {
                bDecrement = true;
            } else if(iTargetSpeed > iCurrentSpeed) {
                bDecrement = false;
            }
            
            if(bDecrement) {
                if(iCurrentSpeed - 10 < iTargetSpeed)
                    iCurrentSpeed = iCurrentSpeed - 1;
                else
                    iCurrentSpeed = iCurrentSpeed - 5;
            } else {
            
                if(iCurrentSpeed + 10 > iTargetSpeed)
                    iCurrentSpeed = iCurrentSpeed + 1;
                else
                    iCurrentSpeed = iCurrentSpeed + 5;
            }
            
            job = setTimeout("draw()", 5);
        }

        function drawWithInputValue() {

            var txtSpeed = document.getElementById('txtSpeed');

            if (txtSpeed !== null) {

                iTargetSpeed = txtSpeed.value;

                // Sanity checks
                if (isNaN(iTargetSpeed)) {
                    iTargetSpeed = 0;
                } else if (iTargetSpeed < 0) {
                    iTargetSpeed = 0;
                } else if (iTargetSpeed > 80) {
                    iTargetSpeed = 80;
                }

                job = setTimeout("draw()", 5);
        
            }
        }












// *********************************************************************************************************


















        function updateMeterWithData(data)
        {
          // const totalRequests = data.reduce((total,item)=> total + item.requests,0);
          const totalRequests = 19;
          const maxReading = 1000;

          const angle = (totalRequests/maxReading)*180;


          document.querySelector('.needle').style.transform = `rotate(${angle}deg)`;
          document.querySelector('.reading').textContent = totalRequests;
        }




        function downloadCSV() {
        var table = document.getElementById("dataList2Table");
        var rows = table.getElementsByTagName("tr");
        var csv = [];

        for (var i = 0; i < rows.length; i++) {
          var row = [], cols = rows[i].querySelectorAll("td, th");
          for (var j = 0; j < cols.length; j++) {
            row.push(cols[j].innerText);
          }
          csv.push(row.join(","));
        }

        var csvContent = "data:text/csv;charset=utf-8," + csv.join("\n");
        var encodedUri = encodeURI(csvContent);
        var link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "table_data.csv");
        document.body.appendChild(link); // Required for FF
        link.click();
      }

    document.getElementById("downloadCSVBtn").addEventListener("click", downloadCSV);
     function showRequests() {
          // document.getElementById("dataContainer1").style.display = "block";
          // document.getElementById("dataContainer2").style.display = "none";
          // document.getElementById("dataContainer3").style.display = "none";
          // document.getElementById("infoTitle").innerText = "Requests handled by Secure Automation";
          var dataContainer2 =document.getElementById("dataContainer2");
          var charts = document.getElementById("linechartsContainer");
          var charts1 = document.getElementById("piechartsContainer");
          var charts2 = document.getElementById("barchartsContainer");
          var dateContainer = document.getElementById("dateContainer");
          var meter = document.getElementById("meter");
          // var chartsContainer1 = document.getElementById("chartsContainer1");

          
          //Show dataContainer2
          charts.style.display = "block";
          dataContainer2.style.display = "block";
          charts1.style.display = "none";
          charts2.style.display = "none";
          dateContainer.style.display = "block";
          meter.style.display ="none";
          // charts.style.display = "none";

          //Hide charts
          //  for(var i=0 ; i< charts.length;i++){
          //   charts[i].style.display = "none";
          //  }
      }
  
      function showApplications() {
          // document.getElementById("dataContainer1").style.display = "none";
          // document.getElementById("dataContainer2").style.display = "block";
          // document.getElementById("dataContainer3").style.display = "none";
          // document.getElementById("infoTitle").innerText = "Information of Applications";
          var dataContainer2 =document.getElementById("dataContainer2");
          var charts2 = document.getElementById("linechartsContainer");
          var dateContainer = document.getElementById("dateContainer");
          var charts = document.getElementById("piechartsContainer");
          var charts1 = document.getElementById("barchartsContainer");
          var meter = document.getElementById("meter");
          //Hide dataContainer2
          
          dataContainer2.style.display = "none";
          dateContainer.style.display = "block";
          charts.style.display = "block";
          charts1.style.display = "block";
          charts2.style.display = "none";
          meter.style.display ="none";
          // dataContainer2.style.display = "block";
          

          // SHOW charts
          //  for(var i=0 ; i< charts.length;i++){
          //   charts[i].style.display = "block";
          //  }
      }
  
      function showBenefit() {
        var meter = document.getElementById("meter");
        var dataContainer2 =document.getElementById("dataContainer2");
          var charts2 = document.getElementById("linechartsContainer");
          var dateContainer = document.getElementById("dateContainer");
          var charts = document.getElementById("piechartsContainer");
          var charts1 = document.getElementById("barchartsContainer");



        meter.style.display ="block";
        dataContainer2.style.display = "none";
          dateContainer.style.display = "none";
          charts.style.display = "none";
          charts1.style.display = "none";
          charts2.style.display = "none";
      }

    // document.getElementById('startDate').addEventListener('change', updateCharts);
    // document.getElementById('endDate').addEventListener('change', updateCharts);

    // document.getElementById('updateButton').addEventListener('click', updateCharts);

    // Fetch data from the server
    function fetchData() {
      // Add logic to fetch data based on the selected date range
      const startDate = document.getElementById('startDate').value;
      const endDate = document.getElementById('endDate').value;

      // Example URL for data fetching (modify as needed)
      const url = `/data?startDate=${startDate}&endDate=${endDate}`;

      fetch(url)
        .then(response => response.json())
        .then(data => {
          // Check if data is available
          if (data && data.data1 && data.data2) {
            const filteredData = data.data2.filter(item => {
              const createdDate = new Date(item.CREATED_DATE).toISOString().split('T')[0];
              return createdDate >= startDate && createdDate <= endDate;
            });
            // Display data for Data Set 1
            displayData('dataList1', data.data1);

            // Display data for Data Set 2
            displayDataTable('dataList2Table', filteredData);

            // Create Bar Chart
            createBarChart('barChart', filteredData);

            // Create Pie Chart
            createPieChart('pieChart', filteredData);

            // Create Line Graph
            // createLineChart('lineChart', filteredData);
            displayLineChart(filteredData);

            //Meter
            updateMeterWithData(data.data1);
          } else {
            console.error('Data is missing or invalid.');
          }
        })
        .catch(error => console.error('Error fetching data:', error));
    }





    //Function to display data in DataTable Format
    function displayDataTable(tableId , data){
      // Destroy existing datatable if exists
      if ($.fn.DataTable.isDataTable(`#${tableId}`)) {
        $(`#${tableId}`).DataTable().destroy();
      }
      //Create a DataTable with paging

      $(`#${tableId}`).DataTable({
        data: data,
        columns: [
          {title: 'REQUESTNO', data: 'REQUESTNO' , render:function(data,type,row,meta){
            return  `<a href="https://secure.uhc.com/User/ViewRequestDetail?requestId=${data}">${data}</a>`;
          }},
          {title: 'SUBREQUEST_NO', data: 'SUBREQUEST_NO'},
          {title: 'APPLICATIONNAME', data: 'APPLICATIONNAME'},
          {title: 'ENVIRONMENT', data: 'ENVIRONMENT'},
          {title: 'REQUESTED_FOR', data: 'REQUESTED_FOR'},
          {title: 'CREATED_DATE', data: 'CREATED_DATE'},
          {title: 'ROLE_NAME', data: 'ROLE_NAME'},
          {title: 'ROLE_STATUS', data: 'ROLE_STATUS'},
          {title: 'REQUEST_STATUS', data: 'REQUEST_STATUS'},
          {title: 'UPDATED_DATE', data: 'UPDATED_DATE'},
          {title: 'COMMENTS', data: 'COMMENTS'},
          {title: 'USER_TL_ID', data: 'USER_TL_ID'},
        ],
        pageLength:5, // number of requests per page
      });
    }
    // Function to update charts based on the selected date range
    function updateCharts() {
      fetchData();
    }
    // Fetch data from the server
    // fetch('/data')
    //   .then(response => response.json())
    //   .then(data => {
    //     // Check if data is available
    //     if (data && data.data1 && data.data2) {
    //       // Display data for Data Set 1
    //       displayDataF('dataList1', data.data1);
    //       // console.log(data.data2);

    //       // Display data for Data Set 2
    //       displayDataF('dataList2', data.data2);
		//   // Create Bar Chart
    //       createBarChart('barChart', data.data2);

    //       // Create Pie Chart
    //       createPieChart('pieChart', data.data2);
    //     } else {
    //       console.error('Data is missing or invalid.');
    //     }
    //   })
    //   .catch(error => console.error('Error fetching data:', error));



		function displayDataF(listId, data) {
      const dataListElement = document.getElementById(listId);

      // Check if data is available
      if (data && data.length > 0) {
        data.forEach(item => {
          // Create a list item
          const listItem = document.createElement('li');
          listItem.className = 'list-group-item';

          // Set the content of the list item based on all properties
          Object.keys(item).forEach(key => {
            listItem.innerHTML += `<strong>${key}:</strong> ${item[key]}<br>`;
          });

          // Append the list item to the ul element
          dataListElement.appendChild(listItem);
        });
      } else {
        // If no data is available, create a placeholder list item
        const listItem = document.createElement('li');
        listItem.className = 'list-group-item';
        listItem.textContent = 'No data available';
        dataListElement.appendChild(listItem);
      }
    }



      function displayData2(listId, data) {
      const dataListElement = document.getElementById(listId);

      // Check if data is available
      if (data && data.length > 0) {
        data.forEach(item => {
          // Create a list item
          const listItem = document.createElement('li');
          listItem.className = 'list-group-item';

          // Set the content of the list item based on all properties
          Object.keys(item).forEach(key => {
            listItem.innerHTML += `<strong>${key}:</strong> ${item[key]}<br>`;
          });

          // Append the list item to the ul element
          dataListElement.appendChild(listItem);
        });
      } else {
        // If no data is available, create a placeholder list item
        const listItem = document.createElement('li');
        listItem.className = 'list-group-item';
        listItem.textContent = 'No data available';
        dataListElement.appendChild(listItem);
      }
    }

    

    
    function displayData(listId, data) {
      const dataListElement = document.getElementById(listId);

      // Check if data is available
      if (data && data.length > 0) {
        data.forEach(item => {
          const listItem = document.createElement('li');
          const columnValue = data[0]['1'] || 'N/A';
          listItem.className = 'list-group-item';
          listItem.textContent = ` ${columnValue}`;
          dataListElement.appendChild(listItem);


          
          
          
          
          
        });
      } else {
        // If no data is available, create a placeholder list item
        const listItem = document.createElement('li');
        listItem.className = 'list-group-item';
        listItem.textContent = 'No data available';
        dataListElement.appendChild(listItem);
      }
    }


      function createBarChart(canvasId, data) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');

      // Group data by APPLICATIONNAME and REQUEST_STATUS
      const groupedData = data.reduce((acc, item) => {
        const appName = item.APPLICATIONNAME;
        const requestStatus = item.REQUEST_STATUS;
        
        if (!acc[appName]) {
          acc[appName] = {
            C: 0,
            RL: 0
          };
        }

        acc[appName][requestStatus]++;
        return acc;
      }, {});

      const labels = Object.keys(groupedData);
      const datasets = Object.entries(groupedData).map(([appName, counts]) => {
        return {
          label: appName,
          data: [counts.C, counts.RL],
          backgroundColor: [
            'rgba(75, 192, 192, 0.2)',
            'rgba(255, 99, 132, 0.2)'
          ],
          borderColor: [
            'rgba(75, 192, 192, 1)',
            'rgba(255, 99, 132, 1)'
          ],
          borderWidth: 1
        };
      });

      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['C', 'RL'],
          datasets: datasets
        },
        options: {
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }



	

      function createPieChart(canvasId, data) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');

      // Group data by APPLICATIONNAME and count occurrences
      const groupedData = data.reduce((acc, item) => {
        const appName = item.APPLICATIONNAME;
        acc[appName] = (acc[appName] || 0) + 1;
        return acc;
      }, {});

      const labels = Object.keys(groupedData);
      const values = Object.values(groupedData);

      new Chart(ctx, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: values,
            backgroundColor: [
              'rgba(255, 99, 132, 0.2)',
              'rgba(54, 162, 235, 0.2)',
              'rgba(255, 206, 86, 0.2)',
              'rgba(75, 192, 192, 0.2)',
              'rgba(153, 102, 255, 0.2)',
              'rgba(255, 159, 64, 0.2)'
            ],
            borderColor: [
              'rgba(255, 99, 132, 1)',
              'rgba(54, 162, 235, 1)',
              'rgba(255, 206, 86, 1)',
              'rgba(75, 192, 192, 1)',
              'rgba(153, 102, 255, 1)',
              'rgba(255, 159, 64, 1)'
            ],
            borderWidth: 1
          }]
        }
      });
    }

    // function updateLineChart(applicationName) {
    //   const url = `/data?applicationName=${applicationName}`;

    //   fetch(url)
    //     .then(response => response.json())
    //     .then(data => {
          


    //     })
    //     .catch(error=> console.error('Error fetching data:', error))
    // }

    // function createLineChart(labels , values){
    //   const ctx = document.getElementById('lineChart').getContext('2d');
    //   new Chart(ctx, {
    //     type:'line',
    //     data:  {
    //       labels:labels,
    //       datasets:[{
    //         label:'Number of Requests',
    //         data:values,
    //         borderColor: 'rgba(255,99,132,1)',
    //         backgroundColor:'rgba(255,99,132,0.2)',
    //         borderWidth:1
    //       }]
    //     },
    //     options:{
    //       scales:{
    //         y:{
    //           beginAtZero:true
    //         }
    //       }
    //     }
    //   });
    // }
      //   function createLineChart(canvasId, data) {
      //   const canvas = document.getElementById(canvasId);
      //   const ctx = canvas.getContext('2d');

      //   // Extract required data from dataList2 for the line chart
      //   const labels = data.map(item => item.APPLICATIONNAME);
      //   const values = data.map(item => {
      //     // Extract the value you want to display on the line chart, such as the number of requests
      //     // You need to adjust this based on your actual data structure
      //     return item.NUMBER_OF_REQUESTS; // Replace 'NUMBER_OF_REQUESTS' with the appropriate property name
      //   });

      //   new Chart(ctx, {
      //     type: 'line',
      //     data: {
      //       labels: labels,
      //       datasets: [{
      //         label: 'Number of Requests',
      //         data: values,
      //         fill: false,
      //         borderColor: 'rgb(75, 192, 192)',
      //         tension: 0.1
      //       }]
      //     },
      //     options: {
      //       scales: {
      //         y: {
      //           beginAtZero: true
      //         }
      //       }
      //     }
      //   });
      // }


      function createLineChart(canvasId, data) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');

      // Extract unique application names
      const groupedData = {};
      for(let i=0;i<12;i++)
      {
        const month = (i+1).toString().padStart(2,'0');
        groupedData[month]=0;
      }
      data.forEach(item => {
        const month = item.CREATED_DATE.split('-')[1];
        groupedData[month] += item.NUMBER_OF_REQUESTS;
      });

      const months = Object.keys(groupedData);
      const requests = Object.values(groupedData);


      new Chart(ctx, {
        type: 'line',
        data: {
          labels:months,
          datasets:[{
            label:'Number of Requests',
            data:requests,
            borderColor:'blue',
            backgroundColor:'rgba(0,0,255,0.1)',
          }]
        },
        options:{
          scales:{
            y:{
              beginAtZero:true,
              title:{
                display:true,
                text:'Number of Requests'
              }
            },
            x:{
              title:{
                display:true,
                text:'Months'
              }
            }
          }
        }
      });

      // const dataList2 = [
      //   { CREATED_DATE:'2024-01-01', NUMBER_OF_REQUESTS:10},
      //   { CREATED_DATE:'2024-02-01', NUMBER_OF_REQUESTS:15},
      //   { CREATED_DATE:'2024-03-01', NUMBER_OF_REQUESTS:25},
      //   { CREATED_DATE:'2024-04-01', NUMBER_OF_REQUESTS:40},
      //   { CREATED_DATE:'2024-05-01', NUMBER_OF_REQUESTS:55},
      //   { CREATED_DATE:'2024-06-01', NUMBER_OF_REQUESTS:70},
      // ]

      // createLineChart('myCanvas',dataList2);








      // const uniqueApplications = [...new Set(data.map(item => item.APPLICATIONNAME))];

      // // Create select dropdown for application selection
      // const selectDropdown = document.createElement('select');
      // selectDropdown.setAttribute('id', 'selectApplication');
      // uniqueApplications.forEach(appName => {
      //   const option = document.createElement('option');
      //   option.text = appName;
      //   selectDropdown.appendChild(option);
      // });

      // // Add event listener to the dropdown
      // selectDropdown.addEventListener('change', () => {
      //   const selectedApplication = selectDropdown.value;
      //   const filteredData = data.filter(item => item.APPLICATIONNAME === selectedApplication);
      //   updateLineChart(ctx, filteredData);
      // });

      // // Append dropdown to canvas parent element
      // canvas.parentNode.appendChild(selectDropdown);

      // // Initialize line chart with the first application's data
      // const initialData = data.filter(item => item.APPLICATIONNAME === uniqueApplications[0]);
      // updateLineChart(ctx, initialData);
    }

    function updateLineChart(ctx, data) {
      // Group data by month
      const groupedData = {};
      data.forEach(item => {
        const monthYear = item.CREATED_DATE.split('-').slice(0, 2).join('-');
        if (!groupedData[monthYear]) {
          groupedData[monthYear] = 0;
        }
        groupedData[monthYear] += item.NUMBER_OF_REQUESTS;
      });

      const labels = Object.keys(groupedData);
      const values = Object.values(groupedData);

      // Clear canvas before drawing the chart
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Number of Requests',
            data: values,
            fill: false,
            borderColor: 'rgb(75, 192, 192)',
            tension: 0.1
          }]
        },
        options: {
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }


    function displayLineChart(data){
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const requestsClosedPerMonth = new Array(12).fill(0);


      data.forEach(entry => {
        const monthIndex = new Date(entry.CREATED_DATE).getMonth();

        requestsClosedPerMonth[monthIndex]++;
      });

      const ctx = document.getElementById('lineChartCanvas').getContext('2d');
      new Chart(ctx, {
        type:'line',
        data:{
          labels:months,
          datasets:[{
            label:'Number of Requests Closed',
            data: requestsClosedPerMonth,
            borderColor:'blue',
            backgroundColor:'rgba(0,0,255,0.1)',
          }]
        },
        options: {
          scales:{
            yAxes:[{
              scaleLabel:{
                display:true,
                labelString:'Number of Requests Closed'
              },
              ticks:{
                beginAtZero:true
              }
            }],
            xAxes:[{
              scaleLabel:{
                display:true,
                labelString:'Months'
              }
            }]
          }
        }
      });
    }
  </script>
</body>
</html>
